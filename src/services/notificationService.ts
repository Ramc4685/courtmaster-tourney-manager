import { supabase } from "@/lib/supabase";
import { Notification, NotificationType } from "@/types/entities";
import { Database } from "@/lib/database.types";

// Define a type for the notification payload, omitting fields generated by DB
type NotificationInsert = Omit<
  Database["public"]["Tables"]["notifications"]["Insert"],
  "id" | "created_at" | "updated_at"
>;

export class NotificationService {
  /**
   * Fetches notifications for a specific user.
   * @param userId - The ID of the user.
   * @returns A promise resolving to an array of notifications.
   */
  async getNotifications(userId: string): Promise<Notification[]> {
    console.log(`[NotificationService] Fetching notifications for user: ${userId}`);
    const { data, error } = await supabase
      .from("notifications")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("[NotificationService] Error fetching notifications:", error);
      throw error;
    }
    console.log(`[NotificationService] Found ${data.length} notifications for user ${userId}`);
    return data as Notification[];
  }

  /**
   * Creates a single notification for a specific user.
   * @param notification - The notification data (user_id, title, message, type).
   * @returns A promise resolving to the created notification.
   */
  async createNotification(
    notification: Pick<
      NotificationInsert,
      "user_id" | "title" | "message" | "type" | "related_entity_id" | "related_entity_type"
    >
  ): Promise<Notification> {
    console.log(`[NotificationService] Creating notification for user: ${notification.user_id}`);
    const { data, error } = await supabase
      .from("notifications")
      .insert({
        ...notification,
        read: false, // Default to unread
      })
      .select()
      .single();

    if (error) {
      console.error("[NotificationService] Error creating notification:", error);
      throw error;
    }
    console.log(`[NotificationService] Notification created with ID: ${data.id}`);
    return data as Notification;
  }

  /**
   * Creates multiple notifications, typically for broadcasting.
   * @param notifications - An array of notification data objects.
   * @returns A promise resolving to an array of created notifications.
   */
  async createMultipleNotifications(
    notifications: NotificationInsert[]
  ): Promise<Notification[]> {
    if (!notifications || notifications.length === 0) {
      console.log("[NotificationService] No notifications to create.");
      return [];
    }
    console.log(`[NotificationService] Creating ${notifications.length} notifications.`);
    
    // Ensure default values are set if not provided
    const notificationsToInsert = notifications.map(n => ({ ...n, read: n.read ?? false }));

    const { data, error } = await supabase
      .from("notifications")
      .insert(notificationsToInsert)
      .select();

    if (error) {
      console.error("[NotificationService] Error creating multiple notifications:", error);
      throw error;
    }
    console.log(`[NotificationService] Successfully created ${data.length} notifications.`);
    return data as Notification[];
  }

  /**
   * Marks a specific notification as read.
   * @param notificationId - The ID of the notification to mark as read.
   * @returns A promise resolving when the operation is complete.
   */
  async markAsRead(notificationId: string): Promise<void> {
    console.log(`[NotificationService] Marking notification as read: ${notificationId}`);
    const { error } = await supabase
      .from("notifications")
      .update({ read: true, updated_at: new Date().toISOString() })
      .eq("id", notificationId);

    if (error) {
      console.error("[NotificationService] Error marking notification as read:", error);
      throw error;
    }
    console.log(`[NotificationService] Notification ${notificationId} marked as read.`);
  }

  /**
   * Marks all unread notifications for a user as read.
   * @param userId - The ID of the user.
   * @returns A promise resolving when the operation is complete.
   */
  async markAllAsRead(userId: string): Promise<void> {
    console.log(`[NotificationService] Marking all notifications as read for user: ${userId}`);
    const { error } = await supabase
      .from("notifications")
      .update({ read: true, updated_at: new Date().toISOString() })
      .eq("user_id", userId)
      .eq("read", false); // Only update unread ones

    if (error) {
      console.error("[NotificationService] Error marking all notifications as read:", error);
      throw error;
    }
    console.log(`[NotificationService] All notifications marked as read for user ${userId}.`);
  }

  /**
   * Deletes a specific notification.
   * @param notificationId - The ID of the notification to delete.
   * @returns A promise resolving when the operation is complete.
   */
  async deleteNotification(notificationId: string): Promise<void> {
    console.log(`[NotificationService] Deleting notification: ${notificationId}`);
    const { error } = await supabase
      .from("notifications")
      .delete()
      .eq("id", notificationId);

    if (error) {
      console.error("[NotificationService] Error deleting notification:", error);
      throw error;
    }
    console.log(`[NotificationService] Notification ${notificationId} deleted.`);
  }

  /**
   * Sends an announcement to all participants of a tournament.
   * This requires fetching participant user IDs first.
   * @param tournamentId - The ID of the tournament.
   * @param title - The title of the announcement.
   * @param message - The message content of the announcement.
   * @returns A promise resolving to the created notification objects.
   */
  async sendTournamentAnnouncement(
    tournamentId: string,
    title: string,
    message: string
  ): Promise<Notification[]> {
    console.log(`[NotificationService] Sending announcement for tournament: ${tournamentId}`);
    try {
      // 1. Fetch all registrations for the tournament
      const { data: registrations, error: regError } = await supabase
        .from("tournament_registrations")
        .select("user_id")
        .eq("tournament_id", tournamentId)
        .eq("status", "confirmed"); // Only notify confirmed participants

      if (regError) {
        console.error("[NotificationService] Error fetching registrations:", regError);
        throw new Error("Could not fetch tournament participants.");
      }

      if (!registrations || registrations.length === 0) {
        console.log("[NotificationService] No confirmed participants found for tournament.");
        return [];
      }

      const userIds = registrations.map((reg) => reg.user_id).filter((id): id is string => !!id);
      const uniqueUserIds = [...new Set(userIds)];

      console.log(`[NotificationService] Found ${uniqueUserIds.length} unique participants.`);

      // 2. Create notification objects for each user
      const notificationsToCreate: NotificationInsert[] = uniqueUserIds.map(
        (userId) => ({
          user_id: userId,
          title: title,
          message: message,
          type: NotificationType.ANNOUNCEMENT,
          read: false,
          related_entity_id: tournamentId,
          related_entity_type: "tournament",
        })
      );

      // 3. Use createMultipleNotifications to insert them
      return await this.createMultipleNotifications(notificationsToCreate);

    } catch (error) {
      console.error("[NotificationService] Failed to send tournament announcement:", error);
      // Rethrow or handle as appropriate
      throw error;
    }
  }
  
  // TODO: Add methods for sending match reminders, score updates, etc.
  // These might involve joining with match schedules, user preferences etc.
  
  // TODO: Consider adding methods to trigger backend functions for Email/SMS
  // async triggerEmailNotification(userId: string, subject: string, body: string) { ... }
  // async triggerSmsNotification(userId: string, message: string) { ... }
}

export const notificationService = new NotificationService();

